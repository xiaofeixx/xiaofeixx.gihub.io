<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="dsadasdasdasdasdasdasdasdsadasdas">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="/img/header.jpg">
    <link rel="alternate" type="application/atom+xml" title="xiaofei" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        了解下AQS｜xiaofei&#39;s blog
        
    </title>

    <link rel="canonical" href="http://haojen.github.io/2020/07/25/谈谈AQS/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<style>

    header.intro-header {
        background-image: url('/img/back.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    xiaofei
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">首页</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Works/">作品</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/Tags/">标签</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="/img/default-image.jpg">


<style>
    
    header.intro-header {
        background-image: url('/img/default-image.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>了解下AQS</h1>
                    
                    <span class="meta">
                         作者 Xiaofei
                        <span>
                          日期 2020-07-25
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#java"
                           title="java">java</a>
                        
						<br/><span id="busuanzi_container_page_pv" style="display:none;">阅读量：
<span id="busuanzi_value_page_pv"></span>次</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            了解下AQS
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h2><p>AQS全称<code>AbstractQueuedSynchronizer</code>，即抽象的队列同步器，是一种用来构建锁和同步器的框架。</p>
<p><strong>基于AQS构建同步器：</strong></p>
<ul>
<li>ReentrantLock</li>
<li>Semaphore</li>
<li>CountDownLatch</li>
<li>ReentrantReadWriteLock</li>
<li>SynchronusQueue</li>
<li>FutureTask</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>AQS 解决了在实现同步器时涉及的大量细节问题，例如自定义标准同步状态、FIFO 同步队列。</li>
<li>基于 AQS 来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</li>
</ul>
<h2 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h2><h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。如图所示：</p>
<p><img src="/img/AQS_CLH.jpg" alt="AQS_CLH"></p>
<p><strong>Sync queue：</strong> 同步队列，是一个双向列表。包括head节点和tail节点。head节点主要用作后续的调度。</p>
<p><img src="/img/sync_queue.jpg" alt="sync_queue"></p>
<p><strong>Condition queue：</strong> 非必须，单向列表。当程序中存在cindition的时候才会存在此列表。</p>
<p><img src="/img/condition_queue.jpg" alt="condition_queue"></p>
<h2 id="内部节点Node"><a href="#内部节点Node" class="headerlink" title="内部节点Node"></a>内部节点Node</h2><p>其实也就是上面队列中的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 标识节点是否是 共享的节点(这样的节点只存在于 Sync Queue 里面) */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  CANCELLED 说明节点已经 取消获取 lock 了(一般是由于 interrupt 或 timeout 导致的)</span></span><br><span class="line"><span class="comment">     *  很多时候是在 cancelAcquire 里面进行设置这个标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SIGNAL 标识当前节点的后继节点需要唤醒(PS: 这个通常是在 独占模式下使用, 在共享模式下有时用 PROPAGATE)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前节点在 Condition Queue 里面</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点获取到 lock 或进行 release lock 时, 共享模式的最终状态是 PROPAGATE(PS: 有可能共享模式的节点变成 PROPAGATE 之前就被其后继节点抢占 head 节点, 而从Sync Queue中被踢出掉)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在 Sync Queue 里面时的前继节点(主要来进行 skip CANCELLED 的节点)</span></span><br><span class="line"><span class="comment">     * 注意: 根据 addWaiter方法:</span></span><br><span class="line"><span class="comment">     *  1. prev节点在队列里面, 则 prev != null 肯定成立</span></span><br><span class="line"><span class="comment">     *  2. prev != null 成立, 不一定 node 就在 Sync Queue 里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node 在 Sync Queue 里面的后继节点, 主要是在release lock 时进行后继节点的唤醒</span></span><br><span class="line"><span class="comment">     * 而后继节点在前继节点上打上 SIGNAL 标识, 来提醒他 release lock 时需要唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 lock 的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用分成两种:</span></span><br><span class="line"><span class="comment">     *  1. 在 Sync Queue 里面, nextWaiter用来判断节点是 共享模式, 还是独占模式</span></span><br><span class="line"><span class="comment">     *  2. 在 Condition queue 里面, 节点主要是链接且后继节点 (Condition queue是一个单向的, 不支持并发的 list)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 node 的前继节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Node 用于 Sync Queue 里面</span></span><br><span class="line">    Node(Thread thread, Node mode)&#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 Node 用于 Condition Queue 里面</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus)&#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>waitStatus的状态变化:</p>
<ol>
<li>线程刚入 Sync Queue 里面, 发现独占锁被其他人获取, 则将其前继节点标记为 SIGNAL, 然后再尝试获取一下锁(调用 tryAcquire 方法)</li>
<li>若调用 tryAcquire 方法获取失败, 则判断一下是否前继节点被标记为 SIGNAL, 若是的话 直接 block(block前会确保前继节点被标记为SIGNAL, 因为前继节点在进行释放锁时根据是否标记为 SIGNAL 来决定唤醒后继节点与否 &lt;- 这是独占的情况下)</li>
<li>前继节点使用完lock, 进行释放, 因为自己被标记为 SIGNAL, 所以唤醒其后继节点</li>
</ol>
<p>waitStatus 变化过程:</p>
<ol>
<li>独占模式下:  0(初始) -&gt; signal(被后继节点标记为release需要唤醒后继节点) -&gt; 0 (等释放好lock, 会恢复到0)</li>
<li>独占模式 + 使用 Condition情况下: 0(初始) -&gt; signal(被后继节点标记为release需要唤醒后继节点) -&gt; 0 (等释放好lock, 会恢复到0)其上可能涉及 中断与超时, 只是多了一个 CANCELLED, 当节点变成 CANCELLED, 后就等着被清除。</li>
<li>共享模式下: 0(初始) -&gt; PROPAGATE(获取 lock 或release lock 时) (获取 lock 时会调用 setHeadAndPropagate 来进行 传递式的唤醒后继节点, 直到碰到 独占模式的节点)</li>
<li>共享模式 + 独占模式下: 0(初始) -&gt; signal(被后继节点标记为release需要唤醒后继节点) -&gt; 0 (等释放好lock, 会恢复到0)</li>
</ol>
<p>其上的这些状态变化主要在: doReleaseShared , shouldParkAfterFailedAcquire 里面。</p>
<h3 id="自定义同步器的实现"><a href="#自定义同步器的实现" class="headerlink" title="自定义同步器的实现"></a>自定义同步器的实现</h3><p>在构建自定义同步器时，只需要依赖AQS底层再实现共享资源state的获取与释放操作即可。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<h2 id="Condition-Queue"><a href="#Condition-Queue" class="headerlink" title="Condition Queue"></a>Condition Queue</h2><p>Condition Queue 是一个并发不安全的, 只用于独占模式的队列(PS: 为什么是并发不安全的呢? 主要是在操作 Condition 时, 线程必需获取 独占的 lock, 所以不需要考虑并发的安全问题); 而当Node存在于 Condition Queue 里面, 则其只有 waitStatus, thread, nextWaiter 有值, 其他的都是null(其中的 waitStatus 只能是 CONDITION, 0(0 代表node进行转移到 Sync Queue里面, 或被中断/timeout)); 这里有个注意点, 就是当线程被中断或获取 lock 超时, 则一瞬间 node 会存在于 Condition Queue, Sync Queue 两个队列中.</p>
<p><img src="/img/condition_queue_detail.jpg" alt="condition_queue_detail"></p>
<p>节点 Node4, Node5, Node6, Node7 都是调用 Condition.awaitXX 方法加入 Condition Queue(PS: 加入后会将原来的 lock 释放)。</p>
<h3 id="入队列方法-addConditionWaiter"><a href="#入队列方法-addConditionWaiter" class="headerlink" title="入队列方法 addConditionWaiter"></a>入队列方法 addConditionWaiter</h3><p>将当前线程封装成一个 Node 节点放入到 Condition Queue 里面大家可以注意到, 下面对 Condition Queue 的操作都没考虑到 并发(Sync Queue 的队列是支持并发操作的), 这是为什么呢? 因为在进行操作 Condition 是当前的线程已经获取了AQS的独占锁, 所以不需要考虑并发的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node t = lastWaiter;                                </span><br><span class="line">    <span class="comment">// Condition queue 的尾节点           </span></span><br><span class="line">	<span class="comment">// 尾节点已经Cancel, 直接进行清除,</span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 当Condition进行 awiat 超时或被中断时, Condition里面的节点是没有被删除掉的, 需要其	 * 他await 在将线程加入 Condition Queue 时调用addConditionWaiter而进而删除, 或 await 操作差不多结束时, 调用 "node.nextWaiter != null" 进行判断而删除 (PS: 通过 signal 进行唤</span></span><br><span class="line"><span class="comment">    * 醒时 node.nextWaiter 会被置空, 而中断和超时时不会)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION)&#123;</span><br><span class="line">    	<span class="comment">/** </span></span><br><span class="line"><span class="comment">    	* 调用 unlinkCancelledWaiters 对 "waitStatus != Node.CONDITION" 的节点进行		* 删除(在Condition里面的Node的waitStatus 要么是CONDITION(正常), 要么就是 0 </span></span><br><span class="line"><span class="comment">    	* (signal/timeout/interrupt))</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        unlinkCancelledWaiters();                     </span><br><span class="line">        t = lastWaiter;                     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将线程封装成 node 准备放入 Condition Queue 里面</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">    	<span class="comment">//Condition Queue 是空的</span></span><br><span class="line">        firstWaiter = node;                           </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 追加到 queue 尾部</span></span><br><span class="line">        t.nextWaiter = node;                          </span><br><span class="line">    &#125;</span><br><span class="line">    lastWaiter = node;                               </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除Cancelled节点的方法-unlinkCancelledWaiters"><a href="#删除Cancelled节点的方法-unlinkCancelledWaiters" class="headerlink" title="删除Cancelled节点的方法 unlinkCancelledWaiters"></a>删除Cancelled节点的方法 unlinkCancelledWaiters</h3><p>当Node在Condition Queue 中, 若状态不是 CONDITION, 则一定是被中断或超时。在调用 addConditionWaiter 将线程放入 Condition Queue 里面时或 awiat 方法获取结束时 进行清理 Condition queue 里面的因 timeout/interrupt 而还存在的节点。这个删除操作比较巧妙, 其中引入了 trail 节点， 可以理解为traverse整个 Condition Queue 时遇到的最后一个有效的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node next = t.nextWaiter;               <span class="comment">// 1. 先初始化 next 节点</span></span><br><span class="line">        <span class="keyword">if</span>(t.waitStatus != Node.CONDITION)&#123;   <span class="comment">// 2. 节点不有效, 在Condition Queue 里面 Node.waitStatus 只有可能是 CONDITION 或是 0(timeout/interrupt引起的)</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;               <span class="comment">// 3. Node.nextWaiter 置空</span></span><br><span class="line">            <span class="keyword">if</span>(trail == <span class="keyword">null</span>)&#123;                  <span class="comment">// 4. 一次都没有遇到有效的节点</span></span><br><span class="line">                firstWaiter = next;            <span class="comment">// 5. 将 next 赋值给 firstWaiter(此时 next 可能也是无效的, 这只是一个临时处理)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                trail.nextWaiter = next;       <span class="comment">// 6. next 赋值给 trail.nextWaiter, 这一步其实就是删除节点 t</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next == <span class="keyword">null</span>)&#123;                  <span class="comment">// 7. next == null 说明 已经 traverse 完了 Condition Queue</span></span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            trail = t;                         <span class="comment">// 8. 将有效节点赋值给 trail</span></span><br><span class="line">        &#125;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移节点的方法-transferForSignal"><a href="#转移节点的方法-transferForSignal" class="headerlink" title="转移节点的方法 transferForSignal"></a>转移节点的方法 transferForSignal</h3><p>transferForSignal只有在节点被正常唤醒才调用的正常转移的方法。<br> 将Node 从Condition Queue 转移到 Sync Queue 里面在调用transferForSignal之前, 会 first.nextWaiter = null;而我们发现若节点是因为 timeout / interrupt 进行转移, 则不会进行这步操作; 两种情况的转移都会把 wautStatus 置为 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))&#123; <span class="comment">// 1. 若 node 已经 cancelled 则失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node p = enq(node);                                 <span class="comment">// 2. 加入 Sync Queue</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))&#123; <span class="comment">// 3. 这里的 ws &gt; 0 指Sync Queue 中node 的前继节点cancelled 了, 所以, 唤醒一下 node ; compareAndSetWaitStatus(p, ws, Node.SIGNAL)失败, 则说明 前继节点已经变成 SIGNAL 或 cancelled, 所以也要 唤醒</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移节点的方法-transferAfterCancelledWait"><a href="#转移节点的方法-transferAfterCancelledWait" class="headerlink" title="转移节点的方法 transferAfterCancelledWait"></a>转移节点的方法 transferAfterCancelledWait</h3><p>transferAfterCancelledWait 在节点获取lock时被中断或获取超时才调用的转移方法。将 Condition Queue 中因 timeout/interrupt 而唤醒的节点进行转移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean transferAfterCancelledWait(Node node)&#123;</span><br><span class="line">    if(compareAndSetWaitStatus(node, Node.CONDITION, 0))&#123; &#x2F;&#x2F; 1. 没有 node 没有 cancelled , 直接进行转移 (转移后, Sync Queue , Condition Queue 都会存在 node)</span><br><span class="line">        enq(node);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(!isOnSyncQueue(node))&#123;                &#x2F;&#x2F; 2.这时是其他的线程发送signal,将本线程转移到 Sync Queue 里面的工程中(转移的过程中 waitStatus &#x3D; 0了, 所以上面的 CAS 操作失败)</span><br><span class="line">        Thread.yield();                         &#x2F;&#x2F; 这里调用 isOnSyncQueue判断是否已经 入Sync Queue 了</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Sync-Queue"><a href="#Sync-Queue" class="headerlink" title="Sync Queue"></a>Sync Queue</h2><p>AQS内部维护着一个FIFO的CLH队列，所以AQS并不支持基于优先级的同步策略。至于为何要选择CLH队列，主要在于CLH锁相对于MSC锁，他更加容易处理cancel和timeout，同时他具备进出队列快、无所、畅通无阻、检查是否有线程在等待也非常容易（head != tail,头尾指针不同）。当然相对于原始的CLH队列锁，ASQ采用的是一种变种的CLH队列锁：</p>
<ol>
<li><p>原始CLH使用的locked自旋，而AQS的CLH则是在每个node里面使用一个状态字段来控制阻塞，而不是自旋。</p>
</li>
<li><p>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段。</p>
</li>
<li><p>head结点使用的是傀儡结点。</p>
</li>
</ol>
<p><img src="/img/sync_queue_detail.jpg" alt="sync_queue_detail"></p>
<h3 id="Sync-Queue-节点入Queue方法"><a href="#Sync-Queue-节点入Queue方法" class="headerlink" title="Sync Queue 节点入Queue方法"></a>Sync Queue 节点入Queue方法</h3><p>这里有个地方需要注意, 就是初始化 head, tail 的节点, 不一定是 head.next, 因为期间可能被其他的线程进行抢占了。将当前的线程封装成 Node 加入到 Sync Queue 里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span></span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);      <span class="comment">// 1. 封装 Node</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span>(pred != <span class="keyword">null</span>)&#123;                           <span class="comment">// 2. pred != null -&gt; 队列中已经有节点, 直接 CAS 到尾节点</span></span><br><span class="line">        node.prev = pred;                       <span class="comment">// 3. 先设置 Node.pre = pred (PS: 则当一个 node在Sync Queue里面时  node.prev 一定 != null(除 dummy node), 但是 node.prev != null 不能说明其在 Sync Queue 里面, 因为现在的CAS可能失败 )</span></span><br><span class="line">        <span class="keyword">if</span>(compareAndSetTail(pred, node))&#123;      <span class="comment">// 4. CAS node 到 tail</span></span><br><span class="line">            pred.next = node;                  <span class="comment">// 5. CAS 成功, 将 pred.next = node (PS: 说明 node.next != null -&gt; 则 node 一定在 Sync Queue, 但若 node 在Sync Queue 里面不一定 node.next != null)</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);                                 <span class="comment">// 6. 队列为空, 调用 enq 入队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个插入会检测head tail 的初始化, 必要的话会初始化一个 dummy 节点, 这个和 ConcurrentLinkedQueue 一样的</span></span><br><span class="line"><span class="comment"> * 将节点 node 加入队列</span></span><br><span class="line"><span class="comment"> * 这里有个注意点</span></span><br><span class="line"><span class="comment"> * 情况:</span></span><br><span class="line"><span class="comment"> *      1. 首先 queue是空的</span></span><br><span class="line"><span class="comment"> *      2. 初始化一个 dummy 节点</span></span><br><span class="line"><span class="comment"> *      3. 这时再在tail后面添加节点(这一步可能失败, 可能发生竞争被其他的线程抢占)</span></span><br><span class="line"><span class="comment"> *  这里为什么要加入一个 dummy 节点呢?</span></span><br><span class="line"><span class="comment"> *      这里的 Sync Queue 是CLH lock的一个变种, 线程节点 node 能否获取lock的判断通过其前继节点</span></span><br><span class="line"><span class="comment"> *      而且这里在当前节点想获取lock时通常给前继节点 打上 signal 的标识(表示前继节点释放lock需要通知我来获取lock)</span></span><br><span class="line"><span class="comment"> *      若这里不清楚的同学, 请先看看 CLH lock的资料 (这是理解 AQS 的基础)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123; <span class="comment">// Must initialize       // 1. 队列为空 初始化一个 dummy 节点 其实和 ConcurrentLinkedQueue 一样</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> Node()))&#123;  <span class="comment">// 2. 初始化 head 与 tail (这个CAS成功后, head 就有值了, 详情将 Unsafe 操作)</span></span><br><span class="line">                tail = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev = t;                      <span class="comment">// 3. 先设置 Node.pre = pred (PS: 则当一个 node在Sync Queue里面时  node.prev 一定 != null, 但是 node.prev != null 不能说明其在 Sync Queue 里面, 因为现在的CAS可能失败 )</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;     <span class="comment">// 4. CAS node 到 tail</span></span><br><span class="line">                t.next = node;                  <span class="comment">// 5. CAS 成功, 将 pred.next = node (PS: 说明 node.next != null -&gt; 则 node 一定在 Sync Queue, 但若 node 在Sync Queue 里面不一定 node.next != null)</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sync-Queue-节点出Queue方法"><a href="#Sync-Queue-节点出Queue方法" class="headerlink" title="Sync Queue 节点出Queue方法"></a>Sync Queue 节点出Queue方法</h3><p>这里的出Queue的方法其实有两个： 新节点获取lock, 调用setHead抢占head, 并且剔除原head；节点因被中断或获取超时而进行 cancelled, 最后被剔除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 head 节点(在独占模式没有并发的可能, 当共享的模式有可能)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 清除线程引用</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>; <span class="comment">// 清除原来 head 的引用 &lt;- 都是 help GC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除因中断/超时而放弃获取lock的线程节点(此时节点在 Sync Queue 里面)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;                 <span class="comment">// 1. 线程引用清空</span></span><br><span class="line"></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)       <span class="comment">// 2.  若前继节点是 CANCELLED 的, 则也一并清除</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">        </span><br><span class="line">    Node predNext = pred.next;         <span class="comment">// 3. 这里的 predNext也是需要清除的(只不过在清除时的 CAS 操作需要 它)</span></span><br><span class="line"></span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 4. 标识节点需要清除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="comment">// 5. 若需要清除额节点是尾节点, 则直接 CAS pred为尾节点</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);    <span class="comment">// 6. 删除节点predNext</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL || <span class="comment">// 7. 后继节点需要唤醒(但这里的后继节点predNext已经 CANCELLED 了)</span></span><br><span class="line">                        (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="comment">// 8. 将 pred 标识为 SIGNAL</span></span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 8. next.waitStatus &lt;= 0 表示 next 是个一个想要获取lock的节点</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 若 pred 是头节点, 则此刻可能有节点刚刚进入 queue ,所以进行一下唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="独占Lock"><a href="#独占Lock" class="headerlink" title="独占Lock"></a>独占Lock</h2><h3 id="独占方式获取lock主要流程"><a href="#独占方式获取lock主要流程" class="headerlink" title="独占方式获取lock主要流程"></a>独占方式获取lock主要流程</h3><ol>
<li>调用 tryAcquire 尝试性的获取锁(一般都是由子类实现), 成功的话直接返回</li>
<li>tryAcquire 调用获取失败, 将当前的线程封装成 Node 加入到 Sync Queue 里面(调用addWaiter), 等待获取 signal 信号</li>
<li>调用 acquireQueued 进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking)</li>
<li>根据acquireQueued的返回值判断在获取lock的过程中是否被中断, 若被中断, 则自己再中断一下(selfInterrupt), 若是响应中断的则直接抛出异常</li>
</ol>
<h3 id="独占方式获取lock主要分成3类"><a href="#独占方式获取lock主要分成3类" class="headerlink" title="独占方式获取lock主要分成3类"></a>独占方式获取lock主要分成3类</h3><ol>
<li>acquire 不响应中断的获取lock, 这里的不响应中断指的是线程被中断后会被唤醒, 并且继续获取lock,在方法返回时, 根据刚才的获取过程是否被中断来决定是否要自己中断一下(方法 selfInterrupt)</li>
<li>doAcquireInterruptibly 响应中断的获取 lock, 这里的响应中断, 指在线程获取 lock 过程中若被中断, 则直接抛出异常</li>
<li>doAcquireNanos 响应中断及超时的获取 lock, 当线程被中断, 或获取超时, 则直接抛出异常, 获取失败</li>
</ol>
<h3 id="独占的获取lock-方法-acquire"><a href="#独占的获取lock-方法-acquire" class="headerlink" title="独占的获取lock 方法 acquire"></a>独占的获取lock 方法 acquire</h3><p>acquire(int arg)：以独占模式获取对象，忽略中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用 tryAcquire 尝试性的获取锁(一般都是又子类实现), 成功的话直接返回</p>
</li>
<li><p>tryAcquire 调用获取失败, 将当前的线程封装成 Node 加入到 Sync Queue 里面(调用addWaiter), 等待获取 signal 信号</p>
</li>
<li><p>调用 acquireQueued 进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking)</p>
</li>
<li><p>根据acquireQueued的返回值判断在获取lock的过程中是否被中断, 若被中断, 则自己再中断一下(selfInterrupt)。</p>
</li>
</ol>
<h3 id="循环获取lock-方法-acquireQueued"><a href="#循环获取lock-方法-acquireQueued" class="headerlink" title="循环获取lock 方法 acquireQueued"></a>循环获取lock 方法 acquireQueued</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();      <span class="comment">// 1. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">                <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;       <span class="comment">// 2. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquire尝试获取一下</span></span><br><span class="line">                    setHead(node);                       <span class="comment">// 3. 获取 lock 成功, 直接设置 新head(原来的head可能就直接被回收)</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC          // help gc</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;                <span class="comment">// 4. 返回在整个获取的过程中是否被中断过 ; 但这又有什么用呢? 若整个过程中被中断过, 则最后我在 自我中断一下 (selfInterrupt), 因为外面的函数可能需要知道整个过程是否被中断过</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 5. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                        parkAndCheckInterrupt())&#123;      <span class="comment">// 6. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(failed)&#123;                             <span class="comment">// 7. 在整个获取中出错</span></span><br><span class="line">                cancelAcquire(node);                <span class="comment">// 8. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主逻辑:</p>
<ol>
<li>当前节点的前继节点是head节点时，先 tryAcquire获取一下锁, 成功的话设置新 head, 返回</li>
<li>第一步不成功, 检测是否需要sleep, 需要的话就sleep, 等待前继节点在释放lock时唤醒或通过中断来唤醒</li>
<li>整个过程可能需要blocking nonblocking 几次</li>
</ol>
<h3 id="支持中断获取lock-方法-doAcquireInterruptibly"><a href="#支持中断获取lock-方法-doAcquireInterruptibly" class="headerlink" title="支持中断获取lock 方法 doAcquireInterruptibly"></a>支持中断获取lock 方法 doAcquireInterruptibly</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);  <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;  <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquire尝试获取一下</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 4. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           <span class="comment">// 5. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();       <span class="comment">// 6. 线程此时唤醒是通过线程中断, 则直接抛异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;                 <span class="comment">// 7. 在整个获取中出错(比如线程中断)</span></span><br><span class="line">            cancelAcquire(node);    <span class="comment">// 8. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireInterruptibly(int arg)： 以独占模式获取对象，如果被中断则中止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();    </span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))       </span><br><span class="line">            doAcquireInterruptibly(arg);     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过先检查中断的状态，然后至少调用一次tryAcquire，返回成功。否则，线程在排队，不停地阻塞与唤醒，调用tryAcquire直到成功或者被中断。</p>
<h3 id="超时-amp-中断获取lock-方法"><a href="#超时-amp-中断获取lock-方法" class="headerlink" title="超时&amp;中断获取lock 方法"></a>超时&amp;中断获取lock 方法</h3><p>tryAcquireNanos(int arg, long nanosTimeout):独占且支持超时模式获取： 带有超时时间，如果经过超时时间则会退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0L</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">// 0. 计算截至时间</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);  <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;  <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquire尝试获取一下</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">// 4. 计算还剩余的时间</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0L</span>)&#123;                      <span class="comment">// 5. 时间超时, 直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)&#123; <span class="comment">// 7. 若没超时, 并且大于spinForTimeoutThreshold, 则线程 sleep(小于spinForTimeoutThreshold, 则直接自旋, 因为效率更高 调用 LockSupport 是需要开销的)</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.interrupted())&#123;                           <span class="comment">// 8. 线程此时唤醒是通过线程中断, 则直接抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;                 <span class="comment">// 9. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node);    <span class="comment">// 10. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试以独占模式获取，如果中断和超时则放弃。实现时先检查中断的状态，然后至少调用一次tryAcquire。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    </span><br><span class="line">     <span class="keyword">if</span> (Thread.interrupted())    </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();    </span><br><span class="line">     <span class="keyword">return</span> tryAcquire(arg)|| doAcquireNanos(arg, nanosTimeout);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放lock方法"><a href="#释放lock方法" class="headerlink" title="释放lock方法"></a>释放lock方法</h3><p>释放 lock 流程：</p>
<ul>
<li>调用子类的 tryRelease 方法释放获取的资源</li>
<li>判断是否完全释放lock(这里有 lock 重复获取的情况)</li>
<li>判断是否有后继节点需要唤醒, 需要的话调用unparkSuccessor进行唤醒</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg))&#123;   <span class="comment">// 1. 调用子类, 若完全释放好, 则返回true(这里有lock重复获取)</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)&#123; <span class="comment">// 2. h.waitStatus !=0 其实就是 h.waitStatus &lt; 0 后继节点需要唤醒</span></span><br><span class="line">            unparkSuccessor(h);   <span class="comment">// 3. 唤醒后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒 node 的后继节点</span></span><br><span class="line"><span class="comment"> * 这里有个注意点: 唤醒时会将当前node的标识归位为 0</span></span><br><span class="line"><span class="comment"> * 等于当前节点标识位 的流转过程: 0(刚加入queue) -&gt; signal (被后继节点要求在释放时需要唤醒) -&gt; 0 (进行唤醒后继节点)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"unparkSuccessor node:"</span> + node + Thread.currentThread().getName());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);       <span class="comment">// 1. 清除前继节点的标识</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    logger.info(<span class="string">"unparkSuccessor s:"</span> + node + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;         <span class="comment">// 2. 这里若在 Sync Queue 里面存在想要获取 lock 的节点,则一定需要唤醒一下(跳过取消的节点)&amp;emsp;（PS: s == null发生在共享模式的竞争释放资源）</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)              <span class="comment">// 3. 找到 queue 里面最前面想要获取 Lock 的节点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"unparkSuccessor s:"</span>+s);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="共享Lock"><a href="#共享Lock" class="headerlink" title="共享Lock"></a>共享Lock</h2><h3 id="共享方式获取lock流程"><a href="#共享方式获取lock流程" class="headerlink" title="共享方式获取lock流程"></a>共享方式获取lock流程</h3><ol>
<li>调用 tryAcquireShared 尝试性的获取锁(一般都是由子类实现), 成功的话直接返回</li>
<li>tryAcquireShared 调用获取失败, 将当前的线程封装成 Node 加入到 Sync Queue 里面(调用addWaiter), 等待获取 signal 信号</li>
<li>在 Sync Queue 里面进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking</li>
<li>当获取失败, 则判断是否可以 block(block的前提是前继节点被打上 SIGNAL 标示)</li>
<li>共享与独占获取lock的区别主要在于 在共享方式下获取 lock 成功会判断是否需要继续唤醒下面的继续获取共享lock的节点(及方法 doReleaseShared)</li>
</ol>
<h3 id="共享方式获取lock主要分成3类"><a href="#共享方式获取lock主要分成3类" class="headerlink" title="共享方式获取lock主要分成3类"></a>共享方式获取lock主要分成3类</h3><ol>
<li>acquireShared 不响应中断的获取lock, 这里的不响应中断指的是线程被中断后会被唤醒, 并且继续获取lock,在方法返回时, 根据刚才的获取过程是否被中断来决定是否要自己中断一下(方法 selfInterrupt)</li>
<li>doAcquireSharedInterruptibly 响应中断的获取 lock, 这里的响应中断, 指在线程获取 lock 过程中若被中断, 则直接抛出异常</li>
<li>doAcquireSharedNanos 响应中断及超时的获取 lock, 当线程被中断, 或获取超时, 则直接抛出异常, 获取失败</li>
</ol>
<h3 id="获取共享lock-方法-acquireShared"><a href="#获取共享lock-方法-acquireShared" class="headerlink" title="获取共享lock 方法 acquireShared"></a>获取共享lock 方法 acquireShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 1. 调用子类, 获取共享 lock  返回 &lt; 0, 表示失败</span></span><br><span class="line">        doAcquireShared(arg);       <span class="comment">// 2. 调用 doAcquireShared 当前 线程加入 Sync Queue 里面, 等待获取 lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取共享lock-方法-doAcquireShared"><a href="#获取共享lock-方法-doAcquireShared" class="headerlink" title="获取共享lock 方法 doAcquireShared"></a>获取共享lock 方法 doAcquireShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);       <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();      <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);      <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span></span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);   <span class="comment">// 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span>(interrupted)&#123;               <span class="comment">// 5. 在获取 lock 时, 被中断过, 则自己再自我中断一下(外面的函数可能需要这个参数)</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           <span class="comment">// 7. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;             <span class="comment">// 8. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node);  <span class="comment">// 9. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取共享lock-方法-doAcquireSharedInterruptibly"><a href="#获取共享lock-方法-doAcquireSharedInterruptibly" class="headerlink" title="获取共享lock 方法 doAcquireSharedInterruptibly"></a>获取共享lock 方法 doAcquireSharedInterruptibly</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);            <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();          <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);          <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span></span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);       <span class="comment">// 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 5. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           <span class="comment">// 6. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();     <span class="comment">// 7. 若此次唤醒是 通过线程中断, 则直接抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;              <span class="comment">// 8. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node); <span class="comment">// 9. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取共享lock-方法-doAcquireSharedNanos"><a href="#获取共享lock-方法-doAcquireSharedNanos" class="headerlink" title="获取共享lock 方法 doAcquireSharedNanos"></a>获取共享lock 方法 doAcquireSharedNanos</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;  <span class="comment">// 0. 计算超时的时间</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);               <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();          <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);          <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span></span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);       <span class="comment">// 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">// 5. 计算还剩余的 timeout , 若小于0 则直接return</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0L</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;         <span class="comment">// 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)&#123;<span class="comment">// 7. 在timeout 小于  spinForTimeoutThreshold 时 spin 的效率, 比 LockSupport 更高</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.interrupted())&#123;                           <span class="comment">// 7. 若此次唤醒是 通过线程中断, 则直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)&#123;                <span class="comment">// 8. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node);    <span class="comment">// 10. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放共享lock"><a href="#释放共享lock" class="headerlink" title="释放共享lock"></a>释放共享lock</h3><p>当 Sync Queue中存在连续多个获取 共享lock的节点时, 会出现并发的唤醒后继节点(因为共享模式下获取lock后会唤醒近邻的后继节点来获取lock)。首先调用子类的 tryReleaseShared来进行释放 lock，然后判断是否需要唤醒后继节点来获取 lock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        Node h = head;                      <span class="comment">// 1. 获取 head 节点, 准备 release</span></span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h != tail)&#123;        <span class="comment">// 2. Sync Queue 里面不为 空</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span>(ws == Node.SIGNAL)&#123;         <span class="comment">// 3. h节点后面可能是 独占的节点, 也可能是 共享的, 并且请求了唤醒(就是给前继节点打标记 SIGNAL)</span></span><br><span class="line">                <span class="keyword">if</span>(!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))&#123; <span class="comment">// 4. h 恢复  waitStatus 值置0 (为啥这里要用 CAS 呢, 因为这里的调用可能是在 节点刚刚获取 lock, 而其他线程又对其进行中断, 所用cas就出现失败)</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                &#125;</span><br><span class="line">                unparkSuccessor(h);         <span class="comment">// 5. 唤醒后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))&#123; <span class="comment">//6. h后面没有节点需要唤醒, 则标识为 PROPAGATE 表示需要继续传递唤醒(主要是区别 独占节点最终状态0 (独占的节点在没有后继节点, 并且release lock 时最终 waitStatus 保存为 0))</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS // 7. 同样这里可能存在竞争</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h == head)&#123; <span class="comment">// 8. head 节点没变化, 直接 return(从这里也看出, 一个共享模式的 节点在其唤醒后继节点时, 只唤醒一个, 但是它会在获取 lock 时唤醒, 释放 lock 时也进行, 所以或导致竞争的操作)</span></span><br><span class="line">            <span class="keyword">break</span>;           <span class="comment">// head 变化了, 说明其他节点获取 lock 了, 自己的任务完成, 直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注：部分图和文字借鉴掘金大佬</p>

                <hr>
                

                <ul class="pager">
                    
                    
                    <li class="next">
                        <a href="/2020/07/12/spring生命周期重谈/" data-toggle="tooltip" data-placement="top"
                           title="spring生命周期重谈">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是AQS？"><span class="toc-text">什么是AQS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心知识"><span class="toc-text">核心知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS核心思想"><span class="toc-text">AQS核心思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部节点Node"><span class="toc-text">内部节点Node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义同步器的实现"><span class="toc-text">自定义同步器的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition-Queue"><span class="toc-text">Condition Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#入队列方法-addConditionWaiter"><span class="toc-text">入队列方法 addConditionWaiter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除Cancelled节点的方法-unlinkCancelledWaiters"><span class="toc-text">删除Cancelled节点的方法 unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移节点的方法-transferForSignal"><span class="toc-text">转移节点的方法 transferForSignal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移节点的方法-transferAfterCancelledWait"><span class="toc-text">转移节点的方法 transferAfterCancelledWait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sync-Queue"><span class="toc-text">Sync Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sync-Queue-节点入Queue方法"><span class="toc-text">Sync Queue 节点入Queue方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sync-Queue-节点出Queue方法"><span class="toc-text">Sync Queue 节点出Queue方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独占Lock"><span class="toc-text">独占Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#独占方式获取lock主要流程"><span class="toc-text">独占方式获取lock主要流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#独占方式获取lock主要分成3类"><span class="toc-text">独占方式获取lock主要分成3类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#独占的获取lock-方法-acquire"><span class="toc-text">独占的获取lock 方法 acquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环获取lock-方法-acquireQueued"><span class="toc-text">循环获取lock 方法 acquireQueued</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#支持中断获取lock-方法-doAcquireInterruptibly"><span class="toc-text">支持中断获取lock 方法 doAcquireInterruptibly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时-amp-中断获取lock-方法"><span class="toc-text">超时&amp;中断获取lock 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放lock方法"><span class="toc-text">释放lock方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享Lock"><span class="toc-text">共享Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享方式获取lock流程"><span class="toc-text">共享方式获取lock流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享方式获取lock主要分成3类"><span class="toc-text">共享方式获取lock主要分成3类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取共享lock-方法-acquireShared"><span class="toc-text">获取共享lock 方法 acquireShared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取共享lock-方法-doAcquireShared"><span class="toc-text">获取共享lock 方法 doAcquireShared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取共享lock-方法-doAcquireSharedInterruptibly"><span class="toc-text">获取共享lock 方法 doAcquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取共享lock-方法-doAcquireSharedNanos"><span class="toc-text">获取共享lock 方法 doAcquireSharedNanos</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放共享lock"><span class="toc-text">释放共享lock</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#java"
                           title="java">java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://juejin.im/user/5dcea6cee51d45081b430994" target="_blank" rel="noopener">掘金</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/tom">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/xiao-bai-xian-sen-12">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/xiaofei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/xiaofeixx">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; xiaofei 2020
					<span id="busuanzi_container_site_pv"" style="font-size: 12px;display:none;">总访问量：<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style="font-size: 12px;display:none;">总访客：<span id="busuanzi_value_site_uv"></span>人</span>
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://haojen.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="img/header.jpg">
</body>

</html>
